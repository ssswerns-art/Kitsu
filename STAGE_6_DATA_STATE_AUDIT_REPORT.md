# ЭТАП 6 — DATA & STATE CONSISTENCY AUDIT

## Дата аудита: 2026-01-22
## Статус: ЗАВЕРШЕНО

---

## ISSUE #1
**Файл:** `backend/app/crud/audit_log.py`  
**Строки:** 40-42

**Описание проблемы:**  
В `AuditLogRepository.create()` выполняется автоматический `commit()` внутри CRUD-метода. Это нарушает принцип разделения ответственности: CRUD не должен управлять транзакциями.

**Тип проблемы:** TRANSACTION

**Почему это баг:**  
- CRUD метод самостоятельно делает `commit()`, что препятствует транзакционной группировке операций
- Если вызывающий код хочет сделать несколько операций в одной транзакции, этот автоматический commit разбивает транзакцию
- В сервисном слое (`AuditService`) уже вызывается этот CRUD метод, и сервис не может контролировать транзакцию

**Как проявляется:**  
- Невозможно объединить создание audit log с другими операциями в одну транзакцию
- Если после создания audit log произойдет ошибка в вызывающем коде, audit log уже будет сохранен (частичный commit)
- Нарушается принцип "все или ничего" для сложных операций

**Риск:** HIGH

**Нужно ли чинить сейчас:** ДА

---

## ISSUE #2
**Файл:** `backend/app/services/admin/anime_service.py`  
**Строки:** 319, 322

**Описание проблемы:**  
После выполнения `session.commit()` (строка 319) выполняется повторный запрос к БД `get_anime()` (строка 322). При этом между commit и get может произойти изменение данных другим процессом.

**Тип проблемы:** DATA

**Почему это баг:**  
- После commit сессия очищается, но объект `updated_anime` становится detached
- Повторный запрос `get_anime()` может вернуть измененные данные, если другой процесс успел их изменить
- Это создает race condition между commit и чтением

**Как проявляется:**  
- Пользователь может получить в ответе данные, которые он не обновлял (если между commit и get кто-то другой изменил anime)
- Нарушается принцип "read your writes"
- В режиме высокой конкуренции клиент может получить неожиданное состояние

**Риск:** MEDIUM

**Нужно ли чинить сейчас:** НЕТ (можно жить с этим, но желательно исправить)

---

## ISSUE #3
**Файл:** `backend/app/crud/permission.py`  
**Строки:** 22-24

**Описание проблемы:**  
В методе `PermissionRepository.create()` выполняется автоматический `commit()` и `refresh()` внутри CRUD-метода.

**Тип проблемы:** TRANSACTION

**Почему это баг:**  
- Аналогично Issue #1: CRUD метод не должен управлять транзакциями
- Автоматический commit препятствует группировке операций
- Refresh после commit может быть избыточным, если объект больше не используется

**Как проявляется:**  
- Невозможно создать permission в рамках большой транзакции
- Если код хочет создать несколько permissions и role_permissions атомарно, commit в середине разбивает транзакцию
- При ошибке после create уже невозможно откатить создание permission

**Риск:** HIGH

**Нужно ли чинить сейчас:** ДА

---

## ISSUE #4
**Файл:** `backend/app/crud/watch_progress.py`  
**Строки:** 152, 176

**Описание проблемы:**  
В `WatchProgressRepository.add()` и `update()` выполняется `commit()` и `rollback()` внутри репозитория.

**Тип проблемы:** TRANSACTION

**Почему это баг:**  
- Репозиторий управляет транзакциями, что нарушает архитектурный принцип
- Обычно управление транзакциями должно быть на уровне use case / service
- Try-except с rollback создает иллюзию безопасности, но скрывает ошибки

**Как проявляется:**  
- Невозможно объединить update progress с другими операциями (например, создание favorite или audit log)
- При ошибке внутри rollback информация об ошибке может быть потеряна
- Если вызывающий код имеет свою транзакционную логику, происходит конфликт управления

**Риск:** MEDIUM

**Нужно ли чинить сейчас:** НЕТ (изолированное использование, но архитектурно неправильно)

---

## ISSUE #5
**Файл:** `backend/app/database.py`  
**Строки:** 20

**Описание проблемы:**  
`AsyncSessionLocal` создан с параметром `expire_on_commit=False`.

**Тип проблемы:** STATE

**Почему это баг:**  
- `expire_on_commit=False` означает, что после commit объекты остаются attached и не становятся detached
- Это может привести к тому, что код будет читать устаревшие (stale) данные из памяти вместо БД
- Если другой процесс изменил данные после commit, объект в памяти не обновится

**Как проявляется:**  
- После commit объект в памяти может содержать старые данные
- Повторное обращение к атрибутам объекта не триггерит refresh из БД
- В распределенной системе или при конкурентных изменениях возникает рассинхрон

**Риск:** MEDIUM

**Нужно ли чинить сейчас:** НЕТ (это может быть осознанный выбор для производительности, но нужно документировать риски)

---

## ISSUE #6
**Файл:** `backend/app/infrastructure/redis.py`  
**Строки:** 268, 282-283, 293-296

**Описание проблемы:**  
Глобальная переменная `_redis_client` используется как singleton без thread-safety механизмов.

**Тип проблемы:** STATE

**Почему это баг:**  
- Глобальная mutable переменная `_redis_client` доступна из разных async tasks
- Инициализация и закрытие использует простое присваивание `global _redis_client`
- При конкурентном вызове `init_redis()` или `close_redis()` может произойти race condition
- Хотя FastAPI обычно вызывает startup/shutdown однократно, нет гарантий при нестандартном использовании

**Как проявляется:**  
- Если два async task одновременно вызовут `init_redis()`, могут создаться две копии клиента
- Если один task вызовет `close_redis()` пока другой использует `get_redis()`, получим закрытое соединение
- В тестах или при перезапуске без корректного shutdown может утечь соединение

**Риск:** LOW

**Нужно ли чинить сейчас:** НЕТ (в production используется только через FastAPI lifecycle, но нужно добавить документацию)

---

## ISSUE #7
**Файл:** `backend/app/config.py`  
**Строки:** 138, 153-156

**Описание проблемы:**  
Глобальная переменная `_settings_instance` используется как lazy singleton без thread-safety.

**Тип проблемы:** STATE

**Почему это баг:**  
- При первом обращении к `get_settings()` происходит инициализация singleton
- Если два async task одновременно вызовут `get_settings()` первый раз, может произойти double initialization
- Нет блокировки или async lock при проверке `if _settings_instance is None`

**Как проявляется:**  
- В теории при конкурентном доступе может создаться две копии Settings
- На практике риск низкий, т.к. обычно settings инициализируются при старте приложения
- В тестах с параллельным запуском может возникнуть race condition

**Риск:** LOW

**Нужно ли чинить сейчас:** НЕТ (в реальности редко проявляется, но можно использовать asyncio.Lock)

---

## ISSUE #8
**Файл:** `backend/app/services/admin/permission_service.py`  
**Строки:** 43, 169-180

**Описание проблемы:**  
В методе `require_permission()` создается новая сессия для AuditService внутри permission check, но commit/rollback не контролируется.

**Тип проблемы:** TRANSACTION

**Почему это баг:**  
- `AuditService(self.session)` использует ту же сессию, но затем внутри audit создается commit (см. Issue #1)
- Если `log_permission_denied()` выполнит commit, это закоммитит все изменения в текущей сессии
- При этом permission check может быть частью большей транзакции
- Try-except с `pass` скрывает ошибки аудита, что может маскировать серьезные проблемы

**Как проявляется:**  
- При ошибке в audit logging основная операция продолжается, но audit log теряется
- Если в сессии были незакоммиченные изменения, они могут быть закоммичены вместе с audit log
- Потенциальная утечка состояния транзакции

**Риск:** MEDIUM

**Нужно ли чинить сейчас:** НЕТ (try-except защищает от падения, но теряется visibility)

---

## ISSUE #9
**Файл:** `backend/app/parser/worker.py`  
**Строки:** 73-74, 84, 128

**Описание проблемы:**  
`ParserWorker` использует instance fields `_running` и `_shutdown_event` для управления состоянием worker'а.

**Тип проблемы:** STATE

**Почему это баг:**  
- Instance fields `_running` и `_shutdown_event` не защищены от конкурентного доступа
- Методы `start()` и `shutdown()` могут быть вызваны из разных async tasks
- Нет гарантий атомарности при проверке и установке `self._running`
- При вызове `start()` дважды может создаться два worker loop'а

**Как проявляется:**  
- Если два task одновременно вызовут `start()`, могут запуститься два цикла worker'а
- При вызове `shutdown()` во время `start()` состояние может быть некорректным
- `asyncio.Event` thread-safe, но логика вокруг него - нет

**Риск:** LOW

**Нужно ли чинить сейчас:** НЕТ (в production обычно один экземпляр worker'а, но можно добавить lock)

---

## ISSUE #10
**Файл:** `backend/app/parser/jobs/autoupdate.py`  
**Строки:** 40, 48-50

**Описание проблемы:**  
`ParserAutoupdateScheduler` использует instance field `_task` для хранения running task, но проверка `if self._task and not self._task.done()` не атомарна.

**Тип проблемы:** STATE

**Почему это баг:**  
- Проверка и установка `_task` не защищены от race conditions
- Если два task одновременно вызовут `start()`, могут создаться два scheduler loop'а
- `_task.cancel()` в `stop()` может быть вызван пока `start()` еще не установил `_task`

**Как проявляется:**  
- При конкурентном вызове `start()` могут запуститься несколько loop'ов
- При вызове `stop()` во время `start()` может произойти неполная остановка
- Memory leak от незавершенных tasks

**Риск:** LOW

**Нужно ли чинить сейчас:** НЕТ (обычно управляется через lifespan FastAPI)

---

## ISSUE #11
**Файл:** `backend/app/models/anime.py` vs `backend/app/schemas/anime_admin.py`
**Строки:** Модель: 26, 52-54; Схема: 54

**Описание проблемы:**  
Несоответствие nullable полей между моделью и схемой:
- Model: `genres: Mapped[list[str] | None]` (nullable)
- Model: `locked_fields: Mapped[list[str] | None]` (nullable, ARRAY)
- Schema: `locked_fields: list[str] | None` (корректно)
- Но в schema нет явной валидации что ARRAY может быть None

**Тип проблемы:** DATA

**Почему это баг:**  
- В PostgreSQL ARRAY может быть NULL, но Pydantic может некорректно обработать это
- При `from_attributes=True` Pydantic может попытать преобразовать NULL в пустой список
- Несоответствие может привести к тому, что None в БД превратится в [] в API

**Как проявляется:**  
- API может возвращать `[]` вместо `null` для locked_fields
- При обновлении может произойти потеря информации о том, был ли массив пустым или отсутствовал
- Семантическая разница между "нет locked fields" и "locked fields не установлены"

**Риск:** LOW

**Нужно ли чинить сейчас:** НЕТ (обычно корректно сериализуется, но стоит проверить)

---

## ISSUE #12
**Файл:** `backend/app/models/episode.py` vs `backend/app/schemas/episode.py`
**Строки:** Модель: 26-27; Схема: 11

**Описание проблемы:**  
Несоответствие полей между моделью и схемой:
- Model: `available_translations: Mapped[list[str] | None] = mapped_column(JSON)`
- Model: `available_qualities: Mapped[list[str] | None] = mapped_column(JSON)`
- Schema: эти поля вообще отсутствуют в `EpisodeRead` и `EpisodeListItem`

**Тип проблемы:** DATA

**Почему это баг:**  
- Model имеет важные поля `available_translations` и `available_qualities`
- Schema не возвращает эти поля в API
- Клиент не может узнать доступные переводы и качества

**Как проявляется:**  
- API возвращает неполную информацию о эпизоде
- Фронтенд не может отобразить список доступных переводов/качеств
- Потенциальная потеря функциональности

**Риск:** MEDIUM

**Нужно ли чинить сейчас:** НЕТ (это не баг state/data consistency, а недостаток функциональности)

---

## ISSUE #13
**Файл:** `backend/app/models/audit_log.py` vs `backend/app/schemas/audit_log.py`
**Строки:** Модель: 23-25 с constraint; Схема: 9

**Описание проблемы:**  
Model имеет строгий constraint на `actor_type` (только 'user', 'system', 'anonymous'), но в schema только Field с min_length/max_length, без enum.

**Тип проблемы:** DATA

**Почему это баг:**  
- Model level validation + DB constraint обеспечивают строгость
- Schema не валидирует допустимые значения actor_type
- При создании через API можно попытаться передать некорректный actor_type
- Ошибка будет поймана только на уровне БД, а не на уровне Pydantic

**Как проявляется:**  
- Некорректные запросы отклоняются с DB error вместо validation error
- Отсутствие ранней валидации на уровне API
- Неинформативные ошибки для клиента (constraint violation вместо "invalid enum value")

**Риск:** LOW

**Нужно ли чинить сейчас:** НЕТ (защита есть на уровне БД и модели, schema можно улучшить)

---

## ISSUE #14
**Файл:** `backend/app/crud/anime_admin.py`
**Строки:** 226, 254

**Описание проблемы:**  
В функциях `update_anime_admin()` и `auto_update_broken_state()` используется `flush()` вместо возможного `commit()`, но вызывающий код должен делать `commit()`.

**Тип проблемы:** TRANSACTION

**Почему это баг:**  
- Функции делают `flush()` для синхронизации с БД (например, для получения generated values)
- Но затем вызывающий код (`AnimeAdminService.update_anime()`) делает `commit()` в строке 319
- Между `flush()` и `commit()` может произойти ошибка, и изменения будут потеряны
- Использование `flush()` создает промежуточное состояние, которое видно в транзакции, но не закоммичено

**Как проявляется:**  
- Если между `flush()` в CRUD и `commit()` в Service произойдет ошибка, данные будут rollback'нуты
- Это корректное поведение, но может быть неочевидным
- Можно было бы ожидать, что CRUD-операция гарантирует сохранение

**Риск:** LOW

**Нужно ли чинить сейчас:** НЕТ (это корректная архитектура: CRUD делает flush, Service делает commit)

---

## ISSUE #15
**Файл:** `backend/app/parser/services/sync_service.py`
**Строки:** 446

**Описание проблемы:**  
В методе `_sync_all_persisted()` есть `await _commit(session)` в конце, но внутри метода уже были вызваны `_run_job()` которые могли сделать rollback.

**Тип проблемы:** TRANSACTION

**Почему это баг:**  
- Метод `_run_job()` (строки 478-498) при ошибке делает `await session.rollback()`
- После rollback в одной из job'ов финальный `commit()` в строке 446 закоммитит только то, что осталось после rollback
- Это может привести к частичному сохранению данных: если catalog sync успешен, schedule sync failed и rollback'нут, но затем episode sync успешен, то catalog и episode сохранятся, а schedule - нет

**Как проявляется:**  
- Несогласованное состояние: часть данных сохранена, часть - нет
- При ошибке в середине sync процесса данные могут быть частично обновлены
- Нарушается принцип атомарности всего sync'а

**Риск:** MEDIUM

**Нужно ли чинить сейчас:** НЕТ (это может быть intentional: сохранить то, что успешно, игнорировать failed части)

---

## ISSUE #16
**Файл:** `backend/app/parser/services/autoupdate_service.py`
**Строки:** 144, 155

**Описание проблемы:**  
В методе `run()` при ошибке делается `rollback()` (строка 144), но затем всё равно делается `commit()` (строка 155).

**Тип проблемы:** TRANSACTION

**Почему это баг:**  
- В try-except блоке (строки 141-153) при exception делается `await self._session.rollback()`
- Но затем после except блока (строка 155) делается `await self._session.commit()`
- После rollback session в "чистом" состоянии, и commit ничего не сделает, но это логически некорректно

**Как проявляется:**  
- После rollback вызывается commit, что может быть confusing
- На практике commit после rollback ничего не сделает (нет pending changes)
- Но это нарушает понятность кода: после failed операции не должно быть commit

**Риск:** LOW

**Нужно ли чинить сейчас:** НЕТ (функционально корректно, но архитектурно странно - commit должен быть только в success path)

---

## SUMMARY

### По типам проблем:
- **TRANSACTION**: 7 issues (#1, #3, #4, #8, #14, #15, #16)
- **STATE**: 4 issues (#5, #6, #7, #9, #10)
- **DATA**: 4 issues (#2, #11, #12, #13)

### По уровню риска:
- **HIGH**: 2 issues (#1, #3) - требуют немедленного исправления
- **MEDIUM**: 6 issues (#2, #4, #5, #8, #12, #15)
- **LOW**: 8 issues (#6, #7, #9, #10, #11, #13, #14, #16)

### Требуют немедленного исправления (ДА):
- Issue #1: AuditLogRepository.create() auto-commit
- Issue #3: PermissionRepository.create() auto-commit

### Рекомендации для следующего этапа:

1. **Критично**: Убрать auto-commit из CRUD методов (Issues #1, #3)
2. **Важно**: Пересмотреть управление транзакциями в репозиториях (Issue #4)
3. **Желательно**: Добавить документацию о `expire_on_commit=False` (Issue #5)
4. **Желательно**: Улучшить schema validation для enum полей (Issue #13)
5. **Можно отложить**: Race conditions в singleton initialization (Issues #6, #7, #9, #10)

### Заключение:

**Основная проблема:** Размытые границы ответственности за управление транзакциями между CRUD, Repository и Service слоями. Некоторые CRUD методы делают auto-commit, что препятствует транзакционной группировке операций.

**Системные риски:** В целом система достаточно стабильна, но есть несколько мест, где автоматический commit может привести к неожиданному поведению при сложных операциях.

**State consistency:** Глобальные singleton'ы (Redis, Settings) потенциально могут иметь race conditions при инициализации, но в production это маловероятно.

**Data consistency:** Несоответствия между моделями и схемами в основном незначительные, за исключением отсутствия некоторых полей в API responses.
